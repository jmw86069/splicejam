% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/jambio-gg.R
\name{stackJunctions}
\alias{stackJunctions}
\title{Stack the y-axis position of junctions}
\usage{
stackJunctions(
  gr,
  scoreColname = "score",
  sampleColname = "sample_id",
  scoreFactor = 1,
  matchFrom = NULL,
  matchTo = NULL,
  strandedScore = TRUE,
  baseline = NULL,
  verbose = FALSE,
  ...
)
}
\arguments{
\item{gr}{GRanges object representing splice junctions.}

\item{scoreColname}{character string matching one of \code{colnames(GenomicRanges::values(gr))}
that contains a numeric value representing the abundance of
each splice junction observed.}

\item{sampleColname}{character string with the column or columns
that contain biological sample identifier, used to ensure junctions
are only stacked within a sample, and not across samples. When
\code{sampleColname} is \code{NULL}, all junctions are stacked.}

\item{scoreFactor}{numeric value multiplied by the value in \code{scoreColname}
to allow scaling the junctions across samples. Note that
\code{scoreFactor} can be a vector, which would be applied to the
vector of scores.}

\item{matchFrom, matchTo}{optional colnames to use when grouping
junctions at the start and end positions. By default \code{"nameFrom"}
and \code{"nameTo"} are used, as output from \code{closestExonToJunctions()},
which has the benefit of grouping junctions within the
\code{spliceBuffer} distance from exon boundaries. If those values
are not present \code{colnames(GenomicRanges::values(gr))} then the new
default \code{c("seqnames", "start", "strand")} is used for
\code{matchFrom}, and \code{c("seqnames", "end", "strand")} is used
for \code{matchTo}. That said, if \code{matchFrom} or \code{matchTo} are supplied,
those colnames are used from \code{as.data.frame(gr)}. Multiple colnames
are allowed.
Note also that \code{sampleColname} is appended to \code{matchFrom} and \code{matchTo}
to ensure that matching is only performed within each
\code{sampleColname} value.}

\item{strandedScore}{logical indicating whether to enforce negative
scores for junctions on the \code{"-"} strand. Note that when \code{strandedScore}
is true, all \code{"-"} strand scores will be negative, and all other
scores with be positive.}

\item{baseline}{numeric vector of length 0, 1 or \code{length(gr)}, with values
added to the y-axis value for junctions.
If \code{baseline} has names matching \code{names(gr)} they will be used for
each \code{gr} entry; if \code{baseline} is not named, values are recycled
to \code{length(gr)}. The purpose is to allow exons to be shifted up
or down on the y-axis, along with associated junctions and
coverage data (see \code{exoncov2polygon()} for another example.)}

\item{verbose}{logical indicating whether to print verbose output.}

\item{...}{additional arguments are ignored.}
}
\value{
GRanges with colnames \code{c("yStart", "yEnd")} added
to \code{values(gr)}, indicating the baseline y-axis position
for the start and end of the junction arc. The score
\code{values(gr)[[scoreColname]]} will reflect the adjustments
by \code{scoreFactor}, and if \code{strandedScore=TRUE} then all
strand \code{"-"} scores will be negative, all other scores
will be positive.
}
\description{
Stack the y-axis position of junctions
}
\details{
This function is intended to help visualize splice junctions
specifically when plotted using \code{geom_diagonal_wide_arc()},
where the height of the junction arc is defined by the \code{score}.
When two junctions have the same start position, their y-positions
are stacked, such that the shorter junction width is placed before
longer junction widths. The intention is to reduce visible overlaps.

The input data is expected to have annotations similar to
those provided by \code{closestExonToJunctions()}, specifically
the columns \code{"nameFrom"} and \code{"nameTo"}, see examples below.
When the input data does not contain columns \code{"nameFrom"} and
and \code{"nameTo"}, the junctions are by default stacked by
coordinates.
}
\examples{
library(GenomicRanges);
library(ggplot2);
library(ggforce);
library(colorjam);
library(jamba);
grExons <- GRanges(seqnames=rep("chr1", 4),
   ranges=IRanges::IRanges(
      start=c(100, 300, 500,  900),
        end=c(200, 400, 750, 1000)),
   strand=rep("+", 4));
names(grExons) <- jamba::makeNames(rep("exon", length(grExons)),
   suffix="");

grJunc <- GRanges(seqnames=rep("chr1", 6),
   ranges=IRanges::IRanges(start=c(200, 200, 400, 400, 750, 750),
      end=c(300, 500, 500, 900, 900, 1200)),
   strand=rep("+", 6),
   score=c(200, 50, 160, 40, 210, 10));
names(grJunc) <- jamba::makeNames(rep("junc", length(grJunc)));

# quick plot showing exons and junctions using rectangles
grl <- c(
   GenomicRanges::GRangesList(exons=grExons),
   split(grJunc, names(grJunc))
   );
ggplot(grl2df(grl), aes(x=x, y=y, group=id, fill=feature_type)) +
   ggforce::geom_shape() +
   scale_y_continuous(breaks=seq_along(grl)-1, labels=names(grl)) +
   colorjam::theme_jam() +
   colorjam::scale_fill_jam() +
   ggtitle("Schematic of exons and junctions GRanges");

# add annotation for closest known exon
grJunc <- closestExonToJunctions(grJunc, grExons, spliceBuffer=5)$spliceGRgene;

# The un-stacked junctions
grlJunc2df1 <- grl2df(grJunc,
   shape="junction",
   doStackJunctions=FALSE);
ggplot(grlJunc2df1, aes(x=x, y=y, group=gr_name, fill=gr_name)) +
   geom_diagonal_wide_arc(alpha=0.7) +
   colorjam::scale_fill_jam() +
   colorjam::theme_jam() +
   ggtitle("Junctions not stacked at boundaries")

# The stacked junctions
grJunc2 <- stackJunctions(grJunc);
grlJunc2df2 <- grl2df(grJunc2,
   scoreArcMinimum=20,
   shape="junction");
ggplot(grlJunc2df2, aes(x=x, y=y, group=gr_name, fill=gr_name)) +
   geom_diagonal_wide_arc(alpha=0.7) +
   colorjam::scale_fill_jam() +
   colorjam::theme_jam() +
   ggtitle("Junctions stacked at boundaries");

## Another view showing the junction_rank
## based upon max reads entering and exiting each exon edge
ggplot(grlJunc2df2, aes(x=x, y=y, group=gr_name)) +
   geom_diagonal_wide_arc(aes(alpha=junction_rank), fill="orange") +
   scale_alpha_manual(values=c(`1`=0.4, `2`=0.6, `3`=0.7)) +
   colorjam::scale_fill_jam() +
   colorjam::theme_jam() +
   ggtitle("Junctions stacked at boundaries")

## Last example showing how two samples are kept separate
grJunc_samples <- c(grJunc, grJunc);
values(grJunc_samples)[,"sample_id"] <- rep(c("SampleA","SampleB"),
   each=length(grJunc));
names(grJunc_samples) <- jamba::makeNames(GenomicRanges::values(grJunc_samples)[,"sample_id"]);
grlJunc2df_samples <- grl2df(grJunc_samples,
   scoreArcMinimum=20,
   shape="junction");
ggplot(grlJunc2df_samples, aes(x=x, y=y, group=gr_name, fill=gr_name)) +
   geom_diagonal_wide_arc(alpha=0.7,
      show.legend=FALSE) +
   colorjam::scale_fill_jam() +
   colorjam::theme_jam() +
   ggtitle("Junctions stacked at boundaries") +
   facet_wrap(~sample_id)

}
\seealso{
Other jam plot functions: 
\code{\link{bgaPlotly3d}()},
\code{\link{factor2label}()},
\code{\link{gene2gg}()},
\code{\link{grl2df}()},
\code{\link{jitter_norm}()},
\code{\link{plotSashimi}()},
\code{\link{prepareSashimi}()}

Other jam GRanges functions: 
\code{\link{addGRLgaps}()},
\code{\link{addGRgaps}()},
\code{\link{annotateGRLfromGRL}()},
\code{\link{annotateGRfromGR}()},
\code{\link{assignGRLexonNames}()},
\code{\link{closestExonToJunctions}()},
\code{\link{combineGRcoverage}()},
\code{\link{exoncov2polygon}()},
\code{\link{findOverlapsGRL}()},
\code{\link{flattenExonsBy}()},
\code{\link{getFirstStrandedFromGRL}()},
\code{\link{getGRLgaps}()},
\code{\link{getGRcoverageFromBw}()},
\code{\link{getGRgaps}()},
\code{\link{grl2df}()},
\code{\link{jam_isDisjoint}()},
\code{\link{make_ref2compressed}()},
\code{\link{sortGRL}()},
\code{\link{spliceGR2junctionDF}()}
}
\concept{jam GRanges functions}
\concept{jam plot functions}
